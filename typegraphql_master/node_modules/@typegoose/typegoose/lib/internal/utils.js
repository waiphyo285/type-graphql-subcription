"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const mongoose = require("mongoose");
const util_1 = require("util");
const logSettings_1 = require("../logSettings");
const types_1 = require("../types");
const constants_1 = require("./constants");
const data_1 = require("./data");
const errors_1 = require("./errors");
/**
 * Returns true, if the type is included in mongoose.Schema.Types
 * @param Type The Type
 * @returns true, if it includes it
 */
function isPrimitive(Type) {
    var _a;
    if (typeof ((_a = Type) === null || _a === void 0 ? void 0 : _a.name) === 'string') {
        // try to match "Type.name" with all the Property Names of "mongoose.Schema.Types"
        // (like "String" with "mongoose.Schema.Types.String")
        return Object.getOwnPropertyNames(mongoose.Schema.Types).includes(Type.name)
            // try to match "Type.name" with all "mongoose.Schema.Types.*.name"
            // (like "SchemaString" with "mongoose.Schema.Types.String.name")
            || Object.values(mongoose.Schema.Types).findIndex((v) => v.name === Type.name) >= 0;
    }
    return false;
}
exports.isPrimitive = isPrimitive;
/**
 * Returns true, if the type is included in mongoose.Schema.Types except the aliases
 * @param Type The Type
 * @returns true, if it includes it
 */
function isAnRefType(Type) {
    var _a;
    if (typeof ((_a = Type) === null || _a === void 0 ? void 0 : _a.name) === 'string') {
        const tmp = Object.getOwnPropertyNames(mongoose.Schema.Types).filter(x => {
            switch (x) {
                case 'Oid':
                case 'Bool':
                case 'Object':
                    return false;
                default:
                    return true;
            }
        });
        // try to match "Type.name" with all the Property Names of "mongoose.Schema.Types" except the ones with aliases
        // (like "String" with "mongoose.Schema.Types.String")
        return tmp.includes(Type.name)
            // try to match "Type.name" with all "mongoose.Schema.Types.*.name"
            // (like "SchemaString" with "mongoose.Schema.Types.String.name")
            || Object.values(mongoose.Schema.Types).findIndex((v) => v.name === Type.name) >= 0;
    }
    return false;
}
exports.isAnRefType = isAnRefType;
/**
 * Returns true, if it is an Object
 * @param Type The Type
 * @param once Just run it once?
 * @returns true, if it is an Object
 */
function isObject(Type, once = false) {
    var _a, _b;
    if (typeof ((_a = Type) === null || _a === void 0 ? void 0 : _a.name) === 'string') {
        let prototype = Type.prototype;
        let name = Type.name;
        while (name) {
            if (name === 'Object' || name === 'Mixed') {
                return true;
            }
            if (once) {
                break;
            }
            prototype = Object.getPrototypeOf(prototype);
            name = (_b = prototype) === null || _b === void 0 ? void 0 : _b.constructor.name;
        }
    }
    return false;
}
exports.isObject = isObject;
/**
 * Returns true, if it is an Number
 * @param Type The Type
 * @returns true, if it is an Number
 */
function isNumber(Type) {
    var _a, _b;
    const name = (_b = (_a = Type) === null || _a === void 0 ? void 0 : _a.name, (_b !== null && _b !== void 0 ? _b : ''));
    return name === 'Number' || name === mongoose.Schema.Types.Number.name;
}
exports.isNumber = isNumber;
/**
 * Returns true, if it is an String
 * @param Type The Type
 * @returns true, if it is an String
 */
function isString(Type) {
    var _a, _b;
    const name = (_b = (_a = Type) === null || _a === void 0 ? void 0 : _a.name, (_b !== null && _b !== void 0 ? _b : ''));
    return name === 'String' || name === mongoose.Schema.Types.String.name;
}
exports.isString = isString;
/**
 * Initialize the property in the schemas Map
 * @param name Name of the current Model/Class
 * @param key Key of the property
 * @param whatis What should it be for a type?
 */
function initProperty(name, key, whatis) {
    if (!data_1.schemas.has(name)) {
        data_1.schemas.set(name, {});
    }
    switch (whatis) {
        case types_1.WhatIsIt.ARRAY:
            data_1.schemas.get(name)[key] = [{}];
            break;
        case types_1.WhatIsIt.MAP:
        case types_1.WhatIsIt.NONE:
            data_1.schemas.get(name)[key] = {};
            break;
        default:
            throw new TypeError('"whatis" is not supplied OR doesn\'t have a case yet!');
    }
}
exports.initProperty = initProperty;
/**
 * Get the Class for a given Document
 * @param document The Document
 */
function getClassForDocument(document) {
    const modelName = document.constructor.modelName;
    return data_1.constructors.get(modelName);
}
exports.getClassForDocument = getClassForDocument;
/**
 * Get the Class for a given Schema
 * @param input
 */
function getClass(input) {
    var _a, _b;
    if (typeof input === 'string') {
        return data_1.constructors.get(input);
    }
    if (typeof ((_a = input) === null || _a === void 0 ? void 0 : _a.typegooseName) === 'string') {
        return data_1.constructors.get(input.typegooseName);
    }
    if (typeof ((_b = input) === null || _b === void 0 ? void 0 : _b.typegooseName) === 'function') {
        return data_1.constructors.get(input.typegooseName());
    }
    throw new ReferenceError('Input was not a string AND didnt have a .typegooseName function AND didnt have a .typegooseName string');
}
exports.getClass = getClass;
/**
 * Return true if there are Options
 * @param options The raw Options
 */
function isWithStringValidate(options) {
    var _a, _b;
    return !isNullOrUndefined((_b = (_a = options.match, (_a !== null && _a !== void 0 ? _a : options.minlength)), (_b !== null && _b !== void 0 ? _b : options.maxlength)));
}
exports.isWithStringValidate = isWithStringValidate;
/**
 * Return true if there are Options
 * @param options The raw Options
 */
function isWithStringTransform(options) {
    var _a, _b;
    return !isNullOrUndefined((_b = (_a = options.lowercase, (_a !== null && _a !== void 0 ? _a : options.uppercase)), (_b !== null && _b !== void 0 ? _b : options.trim)));
}
exports.isWithStringTransform = isWithStringTransform;
/**
 * Return true if there are Options
 * @param options The raw Options
 */
function isWithNumberValidate(options) {
    var _a;
    return !isNullOrUndefined((_a = options.min, (_a !== null && _a !== void 0 ? _a : options.max)));
}
exports.isWithNumberValidate = isWithNumberValidate;
const virtualOptions = ['localField', 'foreignField'];
/**
 * Check if Options include Virtual Populate Options
 * @param options RawOptions of the Prop
 */
function isWithVirtualPOP(options) {
    return Object.keys(options).some((v) => virtualOptions.includes(v));
}
exports.isWithVirtualPOP = isWithVirtualPOP;
exports.allVirtualoptions = virtualOptions.slice(0);
exports.allVirtualoptions.push('ref');
/**
 * Check if All the required Options are present
 * @param options RawOptions of the Prop
 */
function includesAllVirtualPOP(options) {
    return exports.allVirtualoptions.every((v) => Object.keys(options).includes(v));
}
exports.includesAllVirtualPOP = includesAllVirtualPOP;
/**
 * Merge value & existing Metadata & Save it to the class
 * Difference with "mergeMetadata" is that this one DOES save it to the class
 * @param key Metadata key
 * @param value Raw value
 * @param cl The constructor
 * @internal
 */
function assignMetadata(key, value, cl) {
    if (isNullOrUndefined(value)) {
        return value;
    }
    const newValue = mergeMetadata(key, value, cl);
    Reflect.defineMetadata(key, newValue, cl);
    return newValue;
}
exports.assignMetadata = assignMetadata;
/**
 * Merge value & existing Metadata
 * Difference with "assignMetadata" is that this one DOES NOT save it to the class
 * @param key Metadata key
 * @param value Raw value
 * @param cl The constructor
 * @internal
 */
function mergeMetadata(key, value, cl) {
    if (typeof key !== 'string') {
        throw new TypeError(`"${key}"(key) is not a string! (assignMetadata)`);
    }
    if (typeof cl !== 'function') {
        throw new errors_1.NoValidClass(cl);
    }
    // Please don't remove the other values from the function, even when unused - it is made to be clear what is what
    return lodash_1.mergeWith({}, Reflect.getMetadata(key, cl), value, (_objValue, srcValue, ckey, _object, _source, _stack) => customMerger(ckey, srcValue));
}
exports.mergeMetadata = mergeMetadata;
/**
 * Used for lodash customizer's (cloneWith, cloneDeepWith, mergeWith)
 * @param key the key of the current object
 * @param val the value of the object that should get returned for "existingMongoose" & "existingConnection"
 */
function customMerger(key, val) {
    if (isNullOrUndefined(key) || typeof key !== 'string') {
        return undefined;
    }
    if (/^(existingMongoose|existingConnection)$/.test(key)) {
        return val;
    }
    return undefined;
}
/**
 * Merge only schemaOptions from ModelOptions of the class
 * @param value The value to use
 * @param cl The Class to get the values from
 */
function mergeSchemaOptions(value, cl) {
    return mergeMetadata(constants_1.DecoratorKeys.ModelOptions, { schemaOptions: value }, cl).schemaOptions;
}
exports.mergeSchemaOptions = mergeSchemaOptions;
/**
 * Tries to return the right target
 * if target.constructor.name is "Function", return target, otherwise target.constructor
 * @param target The target to determine
 */
function getRightTarget(target) {
    var _a;
    return ((_a = target.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'Function' ? target : target.constructor;
}
exports.getRightTarget = getRightTarget;
/**
 * Get the correct name of the class's model
 * (with suffix)
 * @param cl The Class
 */
function getName(cl) {
    var _a, _b, _c, _d, _e, _f;
    const ctor = getRightTarget(cl);
    const options = (_a = Reflect.getMetadata(constants_1.DecoratorKeys.ModelOptions, ctor), (_a !== null && _a !== void 0 ? _a : {}));
    const baseName = ctor.name;
    if ((_b = options.options) === null || _b === void 0 ? void 0 : _b.automaticName) {
        const suffix = (_d = (_c = options.options) === null || _c === void 0 ? void 0 : _c.customName, (_d !== null && _d !== void 0 ? _d : (_e = options.schemaOptions) === null || _e === void 0 ? void 0 : _e.collection));
        return !isNullOrUndefined(suffix) ? `${baseName}_${suffix}` : baseName;
    }
    if (typeof ((_f = options.options) === null || _f === void 0 ? void 0 : _f.customName) === 'string') {
        if (options.options.customName.length <= 0) {
            throw new TypeError(`"customName" must be a string AND at least one character ("${baseName}")`);
        }
        return options.options.customName;
    }
    return baseName;
}
exports.getName = getName;
/**
 * Returns if it is not defined in "schemas"
 * @param cl The Type
 */
function isNotDefined(cl) {
    return typeof cl === 'function' &&
        !isPrimitive(cl) &&
        cl !== Object &&
        cl !== mongoose.Schema.Types.Buffer &&
        !data_1.schemas.has(getName(cl));
}
exports.isNotDefined = isNotDefined;
/**
 * Map Options to "inner" & "outer"
 * -> inner: means inner of "type: [{here})"
 * -> outer: means outer of "type: [{}], here"
 *
 * Specific to Arrays
 * @param rawOptions The raw options
 * @param Type The Type of the array
 * @param target The Target class
 * @param pkey Key of the Property
 */
function mapArrayOptions(rawOptions, Type, target, pkey, loggerType) {
    var _a, _b;
    logSettings_1.logger.debug('mapArrayOptions called');
    if (!(Type instanceof mongoose.Schema)) {
        loggerType = Type;
    }
    const options = Object.assign({}, rawOptions); // for sanity
    const mapped = mapOptions(rawOptions, Type, target, pkey, false, loggerType);
    /** The Object that gets returned */
    const returnObject = Object.assign(Object.assign({}, mapped.outer), { type: [Object.assign({ type: Type }, mapped.inner)] });
    if (typeof ((_a = options) === null || _a === void 0 ? void 0 : _a.innerOptions) === 'object') {
        for (const [key, value] of Object.entries(options.innerOptions)) {
            returnObject.type[0][key] = value;
        }
    }
    if (typeof ((_b = options) === null || _b === void 0 ? void 0 : _b.outerOptions) === 'object') {
        for (const [key, value] of Object.entries(options.outerOptions)) {
            returnObject[key] = value;
        }
    }
    logSettings_1.logger.debug('(Array) Final mapped Options for Type "%s"', getName(loggerType), returnObject);
    return returnObject;
}
exports.mapArrayOptions = mapArrayOptions;
/**
 * Map Options to "inner" & "outer"
 * @param rawOptions The raw options
 * @param Type The Type of the array
 * @param target The Target class
 * @param pkey Key of the Property
 */
function mapOptions(rawOptions, Type, target, pkey, errorOC = true, loggerType) {
    var _a, _b;
    logSettings_1.logger.debug('mapOptions called');
    /** The Object that gets returned */
    const ret = {
        inner: {},
        outer: {}
    };
    if (!(Type instanceof mongoose.Schema)) {
        loggerType = Type;
        if (getName(loggerType) in mongoose.Schema.Types) {
            logSettings_1.logger.info('Converting "%s" to mongoose Type', getName(loggerType));
            Type = mongoose.Schema.Types[getName(loggerType)];
            /* istanbul ignore next */
            if (Type === mongoose.Schema.Types.Mixed) {
                warnMixed(target, pkey);
            }
        }
    }
    /** The OptionsConstructor to use */
    let OptionsCTOR = (_b = (_a = Type) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b.OptionsConstructor;
    // Fix because "Schema" is not a valid type and doesn't have a ".prototype.OptionsConstructor"
    if (Type instanceof mongoose.Schema) {
        // TODO: remove "as any" cast if "OptionsConstructor" is implemented in @types/mongoose
        OptionsCTOR = mongoose.Schema.Types.Embedded.prototype.OptionsConstructor;
    }
    if (isNullOrUndefined(OptionsCTOR)) {
        if (errorOC) {
            throw new TypeError(`Type does not have an valid "OptionsConstructor"! (${getName(loggerType)} on ${getName(target)}.${pkey})`);
        }
        return ret;
    }
    const options = Object.assign({}, rawOptions); // for sanity
    delete options.items;
    // "mongoose as any" is because the types package does not yet have an entry for "SchemaTypeOptions"
    // TODO: remove "as any" cast if "OptionsConstructor" is implemented in @types/mongoose
    if (OptionsCTOR.prototype instanceof mongoose.SchemaTypeOptions) {
        // console.log("test2", target, pkey, Type, OptionsCTR.prototype);
        for (const [key, value] of Object.entries(options)) {
            if (Object.getOwnPropertyNames(OptionsCTOR.prototype).includes(key)) {
                ret.inner[key] = value;
            }
            else {
                ret.outer[key] = value;
            }
        }
    }
    else {
        logSettings_1.logger.info('The Type "%s" has a property "OptionsConstructor" but it does not extend "SchemaTypeOptions', getName(loggerType));
    }
    logSettings_1.logger.debug('Final mapped Options for Type "%s"', getName(loggerType), ret);
    return ret;
}
exports.mapOptions = mapOptions;
/**
 * Warn, Error or Allow if an mixed type is set
 * -> this function exists for de-duplication
 * @param target Target Class
 * @param key Property key
 */
function warnMixed(target, key) {
    var _a, _b, _c;
    const name = getName(target);
    const modelOptions = (_a = Reflect.getMetadata(constants_1.DecoratorKeys.ModelOptions, getRightTarget(target)), (_a !== null && _a !== void 0 ? _a : {}));
    switch ((_c = (_b = modelOptions) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.allowMixed) {
        default:
        case types_1.Severity.WARN:
            logSettings_1.logger.warn('Implicitly setting "Mixed" is not allowed! (%s, %s)', name, key);
            break;
        case types_1.Severity.ALLOW:
            break;
        case types_1.Severity.ERROR:
            throw new TypeError(util_1.format('Implicitly setting "Mixed" is not allowed! (%s, %s)', name, key));
    }
    return; // always return, if "allowMixed" is not "ERROR"
}
exports.warnMixed = warnMixed;
/**
 * Because since node 4.0.0 the internal util.is* functions got deprecated
 * @param val Any value to test if null or undefined
 */
function isNullOrUndefined(val) {
    return val === null || val === undefined;
}
exports.isNullOrUndefined = isNullOrUndefined;
/**
 * Assign Global ModelOptions if not already existing
 * @param target Target Class
 */
function assignGlobalModelOptions(target) {
    if (isNullOrUndefined(Reflect.getMetadata(constants_1.DecoratorKeys.ModelOptions, target))) {
        logSettings_1.logger.info('Assigning global Schema Options to "%s"', getName(target));
        assignMetadata(constants_1.DecoratorKeys.ModelOptions, lodash_1.omit(data_1.globalOptions, 'globalOptions'), target);
    }
}
exports.assignGlobalModelOptions = assignGlobalModelOptions;
/**
 * Get the status of "_id"
 * -> Check if _id should be present, or not
 * @param Type The Class to check on
 * @param rawOptions baseProp's rawOptions
 */
function get_idStatus(Type, rawOptions) {
    var _a, _b, _c;
    if (typeof ((_a = rawOptions) === null || _a === void 0 ? void 0 : _a._id) === 'boolean') {
        return rawOptions._id;
    }
    const TypeModelOptions = Reflect.getMetadata(constants_1.DecoratorKeys.ModelOptions, Type);
    if (typeof ((_c = (_b = TypeModelOptions) === null || _b === void 0 ? void 0 : _b.schemaOptions) === null || _c === void 0 ? void 0 : _c._id) === 'boolean') {
        return TypeModelOptions.schemaOptions._id;
    }
    return true;
}
exports.get_idStatus = get_idStatus;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW50ZXJuYWwvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxtQ0FBeUM7QUFDekMscUNBQXFDO0FBQ3JDLCtCQUE4QjtBQUU5QixnREFBd0M7QUFDeEMsb0NBV2tCO0FBQ2xCLDJDQUE0QztBQUM1QyxpQ0FBOEQ7QUFDOUQscUNBQXdDO0FBRXhDOzs7O0dBSUc7QUFDSCxTQUFnQixXQUFXLENBQUMsSUFBUzs7SUFDbkMsSUFBSSxjQUFPLElBQUksMENBQUUsSUFBSSxDQUFBLEtBQUssUUFBUSxFQUFFO1FBQ2xDLGtGQUFrRjtRQUNsRixzREFBc0Q7UUFDdEQsT0FBTyxNQUFNLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUMxRSxtRUFBbUU7WUFDbkUsaUVBQWlFO2VBQzlELE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN2RjtJQUVELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQVhELGtDQVdDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLFdBQVcsQ0FBQyxJQUFTOztJQUNuQyxJQUFJLGNBQU8sSUFBSSwwQ0FBRSxJQUFJLENBQUEsS0FBSyxRQUFRLEVBQUU7UUFDbEMsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ3ZFLFFBQVEsQ0FBQyxFQUFFO2dCQUNULEtBQUssS0FBSyxDQUFDO2dCQUNY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