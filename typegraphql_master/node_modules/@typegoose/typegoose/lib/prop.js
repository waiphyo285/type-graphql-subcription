"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mongoose = require("mongoose");
const util_1 = require("util");
const constants_1 = require("./internal/constants");
const data_1 = require("./internal/data");
const errors_1 = require("./internal/errors");
const utils = require("./internal/utils");
const logSettings_1 = require("./logSettings");
const typegoose_1 = require("./typegoose");
const types_1 = require("./types");
/**
 * Base Function for prop & arrayProp
 * @param input All the options needed for prop's
 */
function baseProp(input) {
    const { Type, key, origOptions, target, whatis } = input;
    if (Type === target.constructor) { // prevent "infinite" buildSchema loop / Maximum Stack size exceeded
        throw new TypeError('It seems like the type used is the same as the target class, which is currently not supported\n'
            + `Please look at https://github.com/typegoose/typegoose/issues/42 for more information, for now please avoid using it!`);
    }
    const existingMapForTarget = Reflect.getOwnMetadata(constants_1.DecoratorKeys.PropCache, target);
    if (utils.isNullOrUndefined(existingMapForTarget)) {
        Reflect.defineMetadata(constants_1.DecoratorKeys.PropCache, new Map(), target);
    }
    const mapForTarget = (existingMapForTarget !== null && existingMapForTarget !== void 0 ? existingMapForTarget : Reflect.getOwnMetadata(constants_1.DecoratorKeys.PropCache, target));
    mapForTarget.set(key, { origOptions, Type, target, key, whatis });
    logSettings_1.logger.debug('Added "%s.%s" to the Decorator Cache', utils.getName(target.constructor), key);
}
/**
 * Function that is the actual processing of the prop's (used for caching)
 * @param input All the options needed for prop's
 */
function _buildPropMetadata(input) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    let { Type } = input;
    const { key, origOptions, target, whatis } = input;
    const rawOptions = Object.assign({}, origOptions);
    logSettings_1.logger.debug('Starting to process "%s.%s"', utils.getName(target), key);
    if (!utils.isNullOrUndefined(rawOptions.type)) {
        logSettings_1.logger.info('Prop Option "type" is set to', rawOptions.type);
        Type = rawOptions.type;
        delete rawOptions.type;
    }
    if (utils.isNotDefined(Type)) {
        typegoose_1.buildSchema(Type);
    }
    const name = utils.getName(target);
    if (!data_1.virtuals.has(name)) {
        data_1.virtuals.set(name, new Map());
    }
    if (utils.isWithVirtualPOP(rawOptions)) {
        if (!utils.includesAllVirtualPOP(rawOptions)) {
            throw new errors_1.NotAllVPOPElementsError(name, key);
        }
        data_1.virtuals.get(name).set(key, rawOptions);
        return;
    }
    utils.initProperty(name, key, whatis);
    if (!utils.isNullOrUndefined(rawOptions.set) || !utils.isNullOrUndefined(rawOptions.get)) {
        if (typeof ((_a = rawOptions) === null || _a === void 0 ? void 0 : _a.set) !== 'function') {
            throw new TypeError(`"${name}.${key}" does not have a set function!`);
        }
        if (typeof ((_b = rawOptions) === null || _b === void 0 ? void 0 : _b.get) !== 'function') {
            throw new TypeError(`"${name}.${key}" does not have a get function!`);
        }
        /*
         * Note:
         * this doesn't have a check if prop & returntype of the function is the same,
         * because it can't be accessed at runtime
         */
        data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { type: Type }), rawOptions);
        return;
    }
    const ref = (_c = rawOptions) === null || _c === void 0 ? void 0 : _c.ref;
    // use "rawOptions.refType" if set, otherwise "Type" if it is an suitable ref-type, otherwise default back to "ObjectId"
    const refType = (_f = (_e = (_d = rawOptions) === null || _d === void 0 ? void 0 : _d.refType, (_e !== null && _e !== void 0 ? _e : (utils.isAnRefType(Type) ? Type : undefined))), (_f !== null && _f !== void 0 ? _f : mongoose.Schema.Types.ObjectId));
    if (!utils.isNullOrUndefined(ref)) {
        delete rawOptions.ref;
        const refName = typeof ref === 'string' ? ref : utils.getName(ref);
        switch (whatis) {
            case types_1.WhatIsIt.ARRAY:
                data_1.schemas.get(name)[key][0] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key][0]), { type: refType, ref: refName }), rawOptions);
                break;
            case types_1.WhatIsIt.NONE:
                data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { type: refType, ref: refName }), rawOptions);
                break;
            default:
                throw new TypeError(util_1.format('"ref" is not supported for "%s"! (%s, %s)', whatis, utils.getName(target), key));
        }
        return;
    }
    const refPath = (_g = rawOptions) === null || _g === void 0 ? void 0 : _g.refPath;
    if (refPath) {
        if (typeof refPath !== 'string') {
            throw new TypeError(util_1.format('"refPath" for "%s, %s" should be of type String!', utils.getName(target), key));
        }
        delete rawOptions.refPath;
        switch (whatis) {
            case types_1.WhatIsIt.ARRAY:
                data_1.schemas.get(name)[key][0] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key][0]), { type: refType, refPath }), rawOptions);
                break;
            case types_1.WhatIsIt.NONE:
                data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { type: refType, refPath }), rawOptions);
                break;
            default:
                throw new TypeError(util_1.format('"refPath" is not supported for "%s"! (%s, %s)', whatis, utils.getName(target), key));
        }
        return;
    }
    const enumOption = (_h = rawOptions) === null || _h === void 0 ? void 0 : _h.enum;
    if (!utils.isNullOrUndefined(enumOption)) {
        // check if the supplied value is already "mongoose-consumeable"
        if (!Array.isArray(enumOption)) {
            if (Type === String) {
                rawOptions.enum = Object.entries(enumOption) // get all key-value pairs of the enum
                    // no reverse-filtering because if it is full of strings, there is no reverse mapping
                    .map(([enumKey, enumValue]) => {
                    // safeguard, this should never happen because TypeScript only sets "design:type" to "String"
                    // if the enum is full of strings
                    if (typeof enumValue !== 'string') {
                        throw new errors_1.NotStringTypeError(name, key, enumKey, typeof enumValue);
                    }
                    return enumValue;
                });
            }
            else if (Type === Number) {
                rawOptions.enum = Object.entries(enumOption) // get all key-value pairs of the enum
                    // filter out the "reverse (value -> name) mappings"
                    // https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings
                    .filter(([enumKey, enumValue], _i, arr) => {
                    // safeguard, this should never happen because typescript only sets "design:type" to "Number"
                    // if the enum is full of numbers
                    if (utils.isNullOrUndefined(enumValue) || arr.findIndex(([k]) => k === enumValue.toString()) <= -1) {
                        // if there is no reverse mapping, throw an error
                        throw new errors_1.NotNumberTypeError(name, key, enumKey, typeof enumValue);
                    }
                    return typeof enumValue === 'number';
                })
                    .map(([enumKey, enumValue]) => {
                    if (typeof enumValue !== 'number') {
                        throw new errors_1.NotNumberTypeError(name, key, enumKey, typeof enumValue);
                    }
                    return enumValue;
                });
            }
            else {
                // this will happen if the enum contains both types ("design:type" will be "Object")
                throw new Error(`Invalid type used for map!, got: "${Type}" (${name}.${key})`);
            }
        }
    }
    const selectOption = (_j = rawOptions) === null || _j === void 0 ? void 0 : _j.select;
    if (typeof selectOption === 'boolean') {
        data_1.schemas.get(name)[key] = Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), { select: selectOption });
    }
    {
        // check if Type is actually a real working Type
        if (utils.isNullOrUndefined(Type) || typeof Type !== 'function') {
            throw new errors_1.InvalidTypeError(utils.getName(target), key, Type);
        }
        // check for validation inconsistencies
        if (utils.isWithStringValidate(rawOptions) && !utils.isString(Type)) {
            throw new errors_1.NotStringTypeError(name, key);
        }
        // check for transform inconsistencies
        if (utils.isWithStringTransform(rawOptions) && !utils.isString(Type)) {
            throw new errors_1.NotStringTypeError(name, key);
        }
        if (utils.isWithNumberValidate(rawOptions) && !utils.isNumber(Type)) {
            throw new errors_1.NotNumberTypeError(name, key);
        }
    }
    /** Is this Type (/Class) in the schemas Map? */
    const isInSchemas = data_1.schemas.has(utils.getName(Type));
    if (!isInSchemas && !utils.isPrimitive(Type) && !utils.isObject(Type)) {
        throw new errors_1.InvalidPropError(Type.name, key); // This seems to be never thrown!
    }
    if (utils.isPrimitive(Type)) {
        if (utils.isObject(Type, true)) {
            utils.warnMixed(target, key);
        }
        switch (whatis) {
            case types_1.WhatIsIt.ARRAY:
                data_1.schemas.get(name)[key] = Object.assign(Object.assign({}, data_1.schemas.get(name)[key][0]), utils.mapArrayOptions(rawOptions, Type, target, key));
                return;
            case types_1.WhatIsIt.MAP:
                const mapped = utils.mapOptions(rawOptions, Type, target, key, true);
                data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), mapped.outer), { type: Map, of: Object.assign({ type: Type }, mapped.inner) });
                return;
            case types_1.WhatIsIt.NONE:
                data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), rawOptions), { type: Type });
                return;
            default:
                throw new Error(`"${whatis}"(whatis(primitive)) is invalid for "${name}.${key}"`);
        }
    }
    // If the 'Type' is not a 'Primitive Type' and no subschema was found treat the type as 'Object'
    // so that mongoose can store it as nested document
    if (utils.isObject(Type) && !isInSchemas) {
        utils.warnMixed(target, key);
        data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), rawOptions), { type: mongoose.Schema.Types.Mixed });
        return;
    }
    const virtualSchema = typegoose_1.buildSchema(Type);
    switch (whatis) {
        case types_1.WhatIsIt.ARRAY:
            data_1.schemas.get(name)[key] = Object.assign(Object.assign({}, data_1.schemas.get(name)[key][0]), utils.mapArrayOptions(rawOptions, virtualSchema, target, key, Type));
            return;
        case types_1.WhatIsIt.MAP:
            const mapped = utils.mapOptions(rawOptions, virtualSchema, target, key, false, Type);
            data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), mapped.outer), { type: Map, of: Object.assign({ type: virtualSchema }, mapped.inner) });
            return;
        case types_1.WhatIsIt.NONE:
            data_1.schemas.get(name)[key] = Object.assign(Object.assign(Object.assign({}, data_1.schemas.get(name)[key]), rawOptions), { type: virtualSchema });
            return;
        default:
            throw new Error(`"${whatis}"(whatis(subSchema)) is invalid for "${name}.${key}"`);
    }
}
exports._buildPropMetadata = _buildPropMetadata;
/**
 * Set Property Options for the property below
 * @param options Options
 * @public
 */
function prop(options = {}) {
    return (target, key) => {
        const Type = Reflect.getMetadata(constants_1.DecoratorKeys.Type, target, key);
        if (utils.isNullOrUndefined(Type)) {
            throw new errors_1.NoMetadataError(key);
        }
        // soft errors
        {
            if ('items' in options) {
                logSettings_1.logger.warn('You might not want to use option "items" in a @prop, use @arrayProp (%s.%s)', utils.getName(target), key);
            }
            if ('of' in options) {
                logSettings_1.logger.warn('You might not want to use option "of" in a @prop, use @mapProp (%s.%s)', utils.getName(target), key);
            }
        }
        baseProp({
            Type,
            key,
            origOptions: options,
            target,
            whatis: types_1.WhatIsIt.NONE
        });
    };
}
exports.prop = prop;
/**
 * Set Property(that are Maps) Options for the property below
 * @param options Options for the Map
 * @public
 */
function mapProp(options) {
    return (target, key) => {
        var _a;
        const Type = (_a = options) === null || _a === void 0 ? void 0 : _a.of;
        delete options.of;
        if ('items' in options) {
            logSettings_1.logger.warn('You might not want to use option "items" in a @mapProp, use @arrayProp (%s.%s)', utils.getName(target), key);
        }
        baseProp({
            Type,
            key,
            origOptions: options,
            target,
            whatis: types_1.WhatIsIt.MAP
        });
    };
}
exports.mapProp = mapProp;
/**
 * Set Property(that are Arrays) Options for the property below
 * @param options Options
 * @public
 */
function arrayProp(options) {
    return (target, key) => {
        var _a;
        const Type = (_a = options) === null || _a === void 0 ? void 0 : _a.items;
        if ('of' in options) {
            logSettings_1.logger.warn('You might not want to use option "of" in a @arrayProp, use @mapProp (%s.%s)', utils.getName(target), key);
        }
        if ('items' in options) {
            delete options.items;
        }
        if ('itemsRef' in options) {
            options.ref = options.itemsRef;
            delete options.itemsRef;
        }
        if ('itemsRefPath' in options) {
            options.refPath = options.itemsRefPath;
            delete options.itemsRefPath;
        }
        if ('itemsRefType' in options) {
            options.refType = options.itemsRefType;
            delete options.itemsRefType;
        }
        baseProp({
            Type,
            key,
            origOptions: options,
            target,
            whatis: types_1.WhatIsIt.ARRAY
        });
    };
}
exports.arrayProp = arrayProp;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9wcm9wLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEscUNBQXFDO0FBQ3JDLCtCQUE4QjtBQUU5QixvREFBcUQ7QUFDckQsMENBQW9EO0FBQ3BELDhDQU8yQjtBQUMzQiwwQ0FBMEM7QUFDMUMsK0NBQXVDO0FBQ3ZDLDJDQUEwQztBQUMxQyxtQ0FPaUI7QUFFakI7OztHQUdHO0FBQ0gsU0FBUyxRQUFRLENBQUMsS0FBZ0M7SUFDaEQsTUFBTSxFQUNKLElBQUksRUFDSixHQUFHLEVBQ0gsV0FBVyxFQUNYLE1BQU0sRUFDTixNQUFNLEVBQ1AsR0FBRyxLQUFLLENBQUM7SUFDVixJQUFJLElBQUksS0FBSyxNQUFNLENBQUMsV0FBVyxFQUFFLEVBQUUsb0VBQW9FO1FBQ3JHLE1BQU0sSUFBSSxTQUFTLENBQUMsaUdBQWlHO2NBQ2pILHNIQUFzSCxDQUFDLENBQUM7S0FDN0g7SUFFRCxNQUFNLG9CQUFvQixHQUFHLE9BQU8sQ0FBQyxjQUFjLENBQUMseUJBQWEsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFpQyxDQUFDO0lBQ3JILElBQUksS0FBSyxDQUFDLGlCQUFpQixDQUFDLG9CQUFvQixDQUFDLEVBQUU7UUFDakQsT0FBTyxDQUFDLGNBQWMsQ0FBQyx5QkFBYSxDQUFDLFNBQVMsRUFBRSxJQUFJLEdBQUcsRUFBcUMsRUFBRSxNQUFNLENBQUMsQ0FBQztLQUN2RztJQUNELE1BQU0sWUFBWSxJQUFHLG9CQUFvQixhQUFwQixvQkFBb0IsY0FBcEIsb0JBQW9CLEdBQ3BDLE9BQU8sQ0FBQyxjQUFjLENBQUMseUJBQWEsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFpQyxDQUFBLENBQUM7SUFFN0YsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUVsRSxvQkFB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