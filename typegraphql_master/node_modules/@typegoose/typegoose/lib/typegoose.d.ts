import * as mongoose from 'mongoose';
import 'reflect-metadata';
import * as defaultClasses from './defaultClasses';
import { setGlobalOptions } from './globalOptions';
import { AnyParamConstructor, DocumentType, IModelOptions, Ref, ReturnModelType } from './types';
export { mongoose, setGlobalOptions };
export { setLogLevel, LogLevels } from './logSettings';
export * from './prop';
export * from './hooks';
export * from './plugin';
export * from '.';
export * from './typeguards';
export * from './optionsProp';
export { defaultClasses };
export { DocumentType, Ref, ReturnModelType };
export { Severity, IGlobalOptions } from './types';
export { getClassForDocument, getClass } from './internal/utils';
/** @deprecated */
export declare abstract class Typegoose {
    constructor();
    /** @deprecated */
    getModelForClass<T, U extends AnyParamConstructor<T>>(cl: U, settings?: any): () => any;
    /** @deprecated */
    setModelForClass<T, U extends AnyParamConstructor<T>>(cl: U, settings?: any): () => any;
    /** @deprecated */
    buildSchema<T, U extends AnyParamConstructor<T>>(cl: U): (options?: mongoose.SchemaOptions) => mongoose.Schema<AnyParamConstructor<any>>;
}
/**
 * Get a Model for a Class
 * Executes .setModelForClass if it can't find it already
 * @param cl The uninitialized Class
 * @returns The Model
 * @public
 * @example
 * ```ts
 * class Name {}
 *
 * const NameModel = getModelForClass(Name);
 * ```
 */
export declare function getModelForClass<T, U extends AnyParamConstructor<T>>(cl: U, options?: IModelOptions): ReturnModelType<U, T>;
/**
 * Get Model from internal cache
 * @param key ModelName key
 */
export declare function getModelWithString<U extends AnyParamConstructor<any>>(key: string): undefined | ReturnModelType<U>;
/**
 * Builds the Schema & The Model
 * DEPRECTAED: use getModelForClass
 * @param cl The uninitialized Class
 * @returns The Model
 * @deprecated
 */
export declare function setModelForClass<T, U extends AnyParamConstructor<T>>(cl: U): (options?: IModelOptions) => any;
/**
 * Generates a Mongoose schema out of class props, iterating through all parents
 * @param cl The not initialized Class
 * @returns Returns the Build Schema
 */
export declare function buildSchema<T, U extends AnyParamConstructor<T>>(cl: U, options?: mongoose.SchemaOptions): mongoose.Schema<U>;
/**
 * This can be used to add custom Models to Typegoose, with the type information of cl
 * Note: no gurantee that the type information is fully correct
 * @param model The model to store
 * @param cl The Class to store
 * @example
 * ```ts
 * class T {}
 *
 * const schema = buildSchema(T);
 * // modifications to the schame can be done
 * const model = addModelToTypegoose(mongoose.model(schema), T);
 * ```
 */
export declare function addModelToTypegoose<T, U extends AnyParamConstructor<T>>(model: mongoose.Model<any>, cl: U): ReturnModelType<U, T>;
/**
 * Deletes an existing model so that it can be overwritten
 * with another model
 *
 * @param key
 */
export declare function deleteModel(name: string): void;
/**
 * Delete a model, with the given class
 * @param cl The Class
 */
export declare function deleteModelWithClass<T, U extends AnyParamConstructor<T>>(cl: U): void;
/**
 * Build a Model from a given class and return the model
 * @param from The Model to build From
 * @param cl The Class to make a model out
 * @param id The Identifier to use to differentiate documents (default: cl.name)
 * @example
 * ```ts
 * class C1 {}
 * class C2 extends C1 {}
 *
 * const C1Model = getModelForClass(C1);
 * const C2Model = getDiscriminatorModelForClass(C1Model, C1);
 * ```
 */
export declare function getDiscriminatorModelForClass<T, U extends AnyParamConstructor<T>>(from: mongoose.Model<any>, cl: U, id?: string): ReturnModelType<U, T>;
