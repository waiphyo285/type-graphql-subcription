"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/* imports */
const mongoose = require("mongoose");
exports.mongoose = mongoose;
require("reflect-metadata");
const semver = require("semver");
const util_1 = require("util");
/* istanbul ignore next */
if (semver.lt(mongoose.version, '5.9.2')) {
    throw new Error('Please use mongoose 5.9.2 or higher');
}
if (semver.lt(process.version.slice(1), '8.10.0')) {
    logSettings_1.logger.warn('You are using a NodeJS Version below 8.10.0, Please Upgrade!');
}
const defaultClasses = require("./defaultClasses");
exports.defaultClasses = defaultClasses;
const globalOptions_1 = require("./globalOptions");
exports.setGlobalOptions = globalOptions_1.setGlobalOptions;
const constants_1 = require("./internal/constants");
const data_1 = require("./internal/data");
const errors_1 = require("./internal/errors");
const schema_1 = require("./internal/schema");
const utils_1 = require("./internal/utils");
const logSettings_1 = require("./logSettings");
var logSettings_2 = require("./logSettings");
exports.setLogLevel = logSettings_2.setLogLevel;
exports.LogLevels = logSettings_2.LogLevels;
tslib_1.__exportStar(require("./prop"), exports);
tslib_1.__exportStar(require("./hooks"), exports);
tslib_1.__exportStar(require("./plugin"), exports);
tslib_1.__exportStar(require("."), exports);
tslib_1.__exportStar(require("./typeguards"), exports);
tslib_1.__exportStar(require("./optionsProp"), exports);
var types_1 = require("./types");
exports.Severity = types_1.Severity;
var utils_2 = require("./internal/utils");
exports.getClassForDocument = utils_2.getClassForDocument;
exports.getClass = utils_2.getClass;
globalOptions_1.parseENV(); // call this before anything to ensure they are applied
/** @deprecated */
class Typegoose {
    /* istanbul ignore next */
    constructor() {
        // tslint:disable-next-line:no-empty
        util_1.deprecate(() => { }, 'Typegoose Class is Deprecated!')();
    }
    /* istanbul ignore next */
    /** @deprecated */
    getModelForClass(cl, settings) {
        return util_1.deprecate(getModelForClass.bind(undefined, cl, settings), 'Typegoose Class is Deprecated!');
    }
    /* istanbul ignore next */
    /** @deprecated */
    setModelForClass(cl, settings) {
        return util_1.deprecate(getModelForClass.bind(undefined, cl, settings), 'Typegoose Class is Deprecated!');
    }
    /* istanbul ignore next */
    /** @deprecated */
    buildSchema(cl) {
        return util_1.deprecate(buildSchema.bind(undefined, cl), 'Typegoose Class is Deprecated!');
    }
}
exports.Typegoose = Typegoose;
/**
 * Get a Model for a Class
 * Executes .setModelForClass if it can't find it already
 * @param cl The uninitialized Class
 * @returns The Model
 * @public
 * @example
 * ```ts
 * class Name {}
 *
 * const NameModel = getModelForClass(Name);
 * ```
 */
function getModelForClass(cl, options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if (typeof cl !== 'function') {
        throw new errors_1.NoValidClass(cl);
    }
    options = typeof options === 'object' ? options : {};
    const roptions = utils_1.mergeMetadata(constants_1.DecoratorKeys.ModelOptions, options, cl);
    const name = utils_1.getName(cl);
    if (data_1.models.has(name)) {
        return data_1.models.get(name);
    }
    const model = (_f = (_c = (_b = (_a = roptions) === null || _a === void 0 ? void 0 : _a.existingConnection) === null || _b === void 0 ? void 0 : _b.model.bind(roptions.existingConnection), (_c !== null && _c !== void 0 ? _c : (_e = (_d = roptions) === null || _d === void 0 ? void 0 : _d.existingMongoose) === null || _e === void 0 ? void 0 : _e.model.bind(roptions.existingMongoose))), (_f !== null && _f !== void 0 ? _f : mongoose.model.bind(mongoose)));
    const compiledmodel = model(name, buildSchema(cl, roptions.schemaOptions));
    const refetchedOptions = (_g = Reflect.getMetadata(constants_1.DecoratorKeys.ModelOptions, cl), (_g !== null && _g !== void 0 ? _g : {}));
    if ((_j = (_h = refetchedOptions) === null || _h === void 0 ? void 0 : _h.options) === null || _j === void 0 ? void 0 : _j.runSyncIndexes) {
        compiledmodel.syncIndexes();
    }
    return addModelToTypegoose(compiledmodel, cl);
}
exports.getModelForClass = getModelForClass;
/**
 * Get Model from internal cache
 * @param key ModelName key
 */
function getModelWithString(key) {
    if (typeof key !== 'string') {
        throw new TypeError(util_1.format('Expected "key" to be a string, got "%s"', key));
    }
    return data_1.models.get(key);
}
exports.getModelWithString = getModelWithString;
/* istanbul ignore next */
/**
 * Builds the Schema & The Model
 * DEPRECTAED: use getModelForClass
 * @param cl The uninitialized Class
 * @returns The Model
 * @deprecated
 */
function setModelForClass(cl) {
    return util_1.deprecate(getModelForClass.bind(undefined, cl), 'setModelForClass is deprecated, please use getModelForClass (see README#Migrate to 6.0.0)');
}
exports.setModelForClass = setModelForClass;
/**
 * Generates a Mongoose schema out of class props, iterating through all parents
 * @param cl The not initialized Class
 * @returns Returns the Build Schema
 */
function buildSchema(cl, options) {
    var _a;
    if (typeof cl !== 'function') {
        throw new errors_1.NoValidClass(cl);
    }
    const mergedOptions = utils_1.mergeSchemaOptions(options, cl);
    let sch;
    /** Parent Constructor */
    let parentCtor = Object.getPrototypeOf(cl.prototype).constructor;
    // iterate trough all parents
    while (((_a = parentCtor) === null || _a === void 0 ? void 0 : _a.name) !== 'Object') {
        /* istanbul ignore next */
        if (parentCtor.name === 'Typegoose') { // TODO: remove this "if", if the Typegoose class gets removed [DEPRECATION]
            util_1.deprecate(() => undefined, 'The Typegoose Class is deprecated, please try to remove it')();
            break;
        }
        // extend schema
        sch = schema_1._buildSchema(parentCtor, sch, mergedOptions);
        // set next parent
        parentCtor = Object.getPrototypeOf(parentCtor.prototype).constructor;
    }
    // get schema of current model
    sch = schema_1._buildSchema(cl, sch, mergedOptions);
    return sch;
}
exports.buildSchema = buildSchema;
/**
 * This can be used to add custom Models to Typegoose, with the type information of cl
 * Note: no gurantee that the type information is fully correct
 * @param model The model to store
 * @param cl The Class to store
 * @example
 * ```ts
 * class T {}
 *
 * const schema = buildSchema(T);
 * // modifications to the schame can be done
 * const model = addModelToTypegoose(mongoose.model(schema), T);
 * ```
 */
function addModelToTypegoose(model, cl) {
    if (!(model.prototype instanceof mongoose.Model)) {
        throw new TypeError(`"${model}" is not a valid Model!`);
    }
    if (typeof cl !== 'function') {
        throw new errors_1.NoValidClass(cl);
    }
    const name = utils_1.getName(cl);
    if (data_1.models.has(name)) {
        throw new Error(util_1.format('It seems like "addModelToTypegoose" got called twice\n'
            + 'Or multiple classes with the same name are used, which is not supported!'
            + '(%s)', name));
    }
    if (data_1.constructors.get(name)) {
        logSettings_1.logger.info('Class "%s" already existed in the constructors Map', name);
    }
    data_1.models.set(name, model);
    data_1.constructors.set(name, cl);
    return data_1.models.get(name);
}
exports.addModelToTypegoose = addModelToTypegoose;
/**
 * Deletes an existing model so that it can be overwritten
 * with another model
 *
 * @param key
 */
function deleteModel(name) {
    if (typeof name !== 'string') {
        throw new TypeError('name is not an string! (deleteModel)');
    }
    if (!data_1.models.has(name)) {
        throw new Error(`Model "${name}" could not be found`);
    }
    logSettings_1.logger.debug('Deleting Model "%s"', name);
    data_1.models.get(name).db.deleteModel(name);
    data_1.models.delete(name);
    data_1.constructors.delete(name);
}
exports.deleteModel = deleteModel;
/**
 * Delete a model, with the given class
 * @param cl The Class
 */
function deleteModelWithClass(cl) {
    if (typeof cl !== 'function') {
        throw new errors_1.NoValidClass(cl);
    }
    return deleteModel(utils_1.getName(cl));
}
exports.deleteModelWithClass = deleteModelWithClass;
/**
 * Build a Model from a given class and return the model
 * @param from The Model to build From
 * @param cl The Class to make a model out
 * @param id The Identifier to use to differentiate documents (default: cl.name)
 * @example
 * ```ts
 * class C1 {}
 * class C2 extends C1 {}
 *
 * const C1Model = getModelForClass(C1);
 * const C2Model = getDiscriminatorModelForClass(C1Model, C1);
 * ```
 */
function getDiscriminatorModelForClass(from, cl, id) {
    if (!(from.prototype instanceof mongoose.Model)) {
        throw new TypeError(`"${from}" is not a valid Model!`);
    }
    if (typeof cl !== 'function') {
        throw new errors_1.NoValidClass(cl);
    }
    const name = utils_1.getName(cl);
    if (data_1.models.has(name)) {
        return data_1.models.get(name);
    }
    const sch = buildSchema(cl);
    const discriminatorKey = sch.get('discriminatorKey');
    if (sch.path(discriminatorKey)) {
        sch.paths[discriminatorKey].options.$skipDiscriminatorCheck = true;
    }
    const model = from.discriminator(name, sch, id ? id : name);
    return addModelToTypegoose(model, cl);
}
exports.getDiscriminatorModelForClass = getDiscriminatorModelForClass;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZWdvb3NlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3R5cGVnb29zZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxhQUFhO0FBQ2IscUNBQXFDO0FBK0I1Qiw0QkFBUTtBQTlCakIsNEJBQTBCO0FBQzFCLGlDQUFpQztBQUNqQywrQkFBeUM7QUFFekMsMEJBQTBCO0FBQzFCLElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxFQUFFO0lBQ3hDLE1BQU0sSUFBSSxLQUFLLENBQUMscUNBQXFDLENBQUMsQ0FBQztDQUN4RDtBQUVELElBQUksTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxRQUFRLENBQUMsRUFBRTtJQUNqRCxvQkFBTSxDQUFDLElBQUksQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO0NBQzdFO0FBRUQsbURBQW1EO0FBeUIxQyx3Q0FBYztBQXhCdkIsbURBQTZEO0FBZ0IxQywyQkFoQkEsZ0NBQWdCLENBZ0JBO0FBZm5DLG9EQUFxRDtBQUNyRCwwQ0FBdUQ7QUFDdkQsOENBQWlEO0FBQ2pELDhDQUFpRDtBQUNqRCw0Q0FBOEU7QUFDOUUsK0NBQXVDO0FBV3ZDLDZDQUF1RDtBQUE5QyxvQ0FBQSxXQUFXLENBQUE7QUFBRSxrQ0FBQSxTQUFTLENBQUE7QUFDL0IsaURBQXVCO0FBQ3ZCLGtEQUF3QjtBQUN4QixtREFBeUI7QUFDekIsNENBQWtCO0FBQ2xCLHVEQUE2QjtBQUM3Qix3REFBOEI7QUFHOUIsaUNBQW1EO0FBQTFDLDJCQUFBLFFBQVEsQ0FBQTtBQUNqQiwwQ0FBaUU7QUFBeEQsc0NBQUEsbUJBQW1CLENBQUE7QUFBRSwyQkFBQSxRQUFRLENBQUE7QUFFdEMsd0JBQVEsRUFBRSxDQUFDLENBQUMsdURBQXVEO0FBRW5FLGtCQUFrQjtBQUNsQixNQUFzQixTQUFTO0lBQzdCLDBCQUEw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